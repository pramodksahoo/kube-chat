
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>middleware: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/pramodksahoo/kube-chat/pkg/middleware/auth.go (78.3%)</option>
				
				<option value="file1">github.com/pramodksahoo/kube-chat/pkg/middleware/circuit_breaker.go (93.3%)</option>
				
				<option value="file2">github.com/pramodksahoo/kube-chat/pkg/middleware/jwt.go (44.1%)</option>
				
				<option value="file3">github.com/pramodksahoo/kube-chat/pkg/middleware/saml.go (42.0%)</option>
				
				<option value="file4">github.com/pramodksahoo/kube-chat/pkg/middleware/security.go (73.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package middleware provides authentication and authorization middleware for the KubeChat API
package middleware

import (
        "context"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/coreos/go-oidc/v3/oidc"
        "github.com/gofiber/fiber/v3"
        "golang.org/x/oauth2"
)

// OIDCProvider represents configuration for different OIDC providers
type OIDCProvider struct {
        Name         string `json:"name"`
        Issuer       string `json:"issuer"`
        ClientID     string `json:"client_id"`
        ClientSecret string `json:"client_secret"`
        RedirectURL  string `json:"redirect_url"`
        Scopes       []string `json:"scopes"`
        // Provider-specific settings
        ExtraParams map[string]string `json:"extra_params,omitempty"`
}

// AuthMiddleware handles OIDC authentication for KubeChat
type AuthMiddleware struct {
        providers       map[string]*ProviderConfig
        jwtService      JWTServiceInterface
        circuitBreakers map[string]*CircuitBreaker
        enableFallback  bool
}

// ProviderConfig holds runtime configuration for an OIDC provider
type ProviderConfig struct {
        Provider     *oidc.Provider
        OAuth2Config oauth2.Config
        Settings     OIDCProvider
        Verifier     *oidc.IDTokenVerifier
}

// AuthenticationError represents authentication-related errors
type AuthenticationError struct {
        Code    string `json:"code"`
        Message string `json:"message"`
        Details string `json:"details,omitempty"`
}

func (e *AuthenticationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("Authentication error [%s]: %s", e.Code, e.Message)
}</span>

// NewAuthMiddleware creates a new authentication middleware instance
func NewAuthMiddleware(providers []OIDCProvider, jwtService JWTServiceInterface) (*AuthMiddleware, error) <span class="cov8" title="1">{
        if len(providers) == 0 </span><span class="cov8" title="1">{
                return nil, &amp;AuthenticationError{
                        Code:    "CONFIG_ERROR",
                        Message: "At least one OIDC provider must be configured",
                }
        }</span>

        <span class="cov8" title="1">middleware := &amp;AuthMiddleware{
                providers:       make(map[string]*ProviderConfig),
                jwtService:      jwtService,
                circuitBreakers: make(map[string]*CircuitBreaker),
                enableFallback:  true,
        }

        // Initialize each provider
        for _, providerSettings := range providers </span><span class="cov8" title="1">{
                config, err := middleware.initializeProvider(providerSettings)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to initialize provider %s: %w", providerSettings.Name, err)
                }</span>
                <span class="cov8" title="1">middleware.providers[providerSettings.Name] = config

                // Initialize circuit breaker for each provider
                cbConfig := CircuitBreakerConfig{
                        FailureThreshold: 5,
                        SuccessThreshold: 2,
                        Timeout:          30 * time.Second,
                        MaxRequests:      10,
                        OnStateChange: func(state CircuitBreakerState) </span><span class="cov0" title="0">{
                                // Log state changes for monitoring
                                fmt.Printf("Circuit breaker for provider %s changed to %v\n", providerSettings.Name, state)
                        }</span>,
                }
                <span class="cov8" title="1">middleware.circuitBreakers[providerSettings.Name] = NewCircuitBreaker(cbConfig)</span>
        }

        <span class="cov8" title="1">return middleware, nil</span>
}

// initializeProvider initializes a single OIDC provider
func (m *AuthMiddleware) initializeProvider(settings OIDCProvider) (*ProviderConfig, error) <span class="cov8" title="1">{
        ctx := context.Background()

        // Discover OIDC provider
        provider, err := oidc.NewProvider(ctx, settings.Issuer)
        if err != nil </span><span class="cov8" title="1">{
                return nil, &amp;AuthenticationError{
                        Code:    "PROVIDER_DISCOVERY_FAILED",
                        Message: fmt.Sprintf("Failed to discover OIDC provider at %s", settings.Issuer),
                        Details: err.Error(),
                }
        }</span>

        // Create OAuth2 configuration
        <span class="cov8" title="1">oauth2Config := oauth2.Config{
                ClientID:     settings.ClientID,
                ClientSecret: settings.ClientSecret,
                RedirectURL:  settings.RedirectURL,
                Endpoint:     provider.Endpoint(),
                Scopes:       append([]string{oidc.ScopeOpenID}, settings.Scopes...),
        }

        // Create ID token verifier
        verifier := provider.Verifier(&amp;oidc.Config{ClientID: settings.ClientID})

        return &amp;ProviderConfig{
                Provider:     provider,
                OAuth2Config: oauth2Config,
                Settings:     settings,
                Verifier:     verifier,
        }, nil</span>
}

// RequireAuthentication middleware that requires valid authentication
func (m *AuthMiddleware) RequireAuthentication() fiber.Handler <span class="cov8" title="1">{
        return func(c fiber.Ctx) error </span><span class="cov8" title="1">{
                // Check for JWT token in Authorization header
                authHeader := c.Get("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        return m.sendAuthenticationError(c, "MISSING_TOKEN", "Authorization header required", http.StatusUnauthorized)
                }</span>

                // Extract token from "Bearer &lt;token&gt;" format
                <span class="cov8" title="1">tokenParts := strings.Split(authHeader, " ")
                if len(tokenParts) != 2 || strings.ToLower(tokenParts[0]) != "bearer" </span><span class="cov0" title="0">{
                        return m.sendAuthenticationError(c, "INVALID_TOKEN_FORMAT", "Authorization header must be in format 'Bearer &lt;token&gt;'", http.StatusUnauthorized)
                }</span>

                <span class="cov8" title="1">token := tokenParts[1]

                // Validate JWT token
                claims, err := m.jwtService.ValidateToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        return m.sendAuthenticationError(c, "INVALID_TOKEN", "Token validation failed", http.StatusUnauthorized)
                }</span>

                // Add user context to request
                <span class="cov8" title="1">c.Locals("user", claims)
                c.Locals("user_id", claims.UserID)
                c.Locals("session_id", claims.SessionID)

                return c.Next()</span>
        }
}

// GetAuthURL returns the authorization URL for a specific provider
func (m *AuthMiddleware) GetAuthURL(providerName string, state string) (string, error) <span class="cov8" title="1">{
        config, exists := m.providers[providerName]
        if !exists </span><span class="cov8" title="1">{
                return "", &amp;AuthenticationError{
                        Code:    "PROVIDER_NOT_FOUND",
                        Message: fmt.Sprintf("Provider %s not configured", providerName),
                }
        }</span>

        // Add provider-specific extra parameters
        <span class="cov8" title="1">opts := []oauth2.AuthCodeOption{}
        for key, value := range config.Settings.ExtraParams </span><span class="cov0" title="0">{
                opts = append(opts, oauth2.SetAuthURLParam(key, value))
        }</span>

        // Handle MFA requirements for specific providers
        <span class="cov8" title="1">switch strings.ToLower(providerName) </span>{
        case "okta":<span class="cov0" title="0">
                // Okta-specific MFA handling
                opts = append(opts, oauth2.SetAuthURLParam("prompt", "login"))</span>
        case "auth0":<span class="cov0" title="0">
                // Auth0-specific MFA handling
                opts = append(opts, oauth2.SetAuthURLParam("prompt", "login"))</span>
        case "azure", "microsoft":<span class="cov0" title="0">
                // Azure AD-specific MFA handling
                opts = append(opts, oauth2.SetAuthURLParam("prompt", "login"))</span>
        case "google":<span class="cov8" title="1">
                // Google Workspace MFA handling
                opts = append(opts, oauth2.SetAuthURLParam("prompt", "select_account consent"))</span>
        }

        <span class="cov8" title="1">return config.OAuth2Config.AuthCodeURL(state, opts...), nil</span>
}

// HandleCallback processes the OIDC callback
func (m *AuthMiddleware) HandleCallback(c fiber.Ctx) error <span class="cov8" title="1">{
        // Get provider from query parameter or path
        providerName := c.Query("provider")
        if providerName == "" </span><span class="cov8" title="1">{
                providerName = c.Params("provider")
        }</span>
        <span class="cov8" title="1">if providerName == "" </span><span class="cov0" title="0">{
                return m.sendAuthenticationError(c, "MISSING_PROVIDER", "Provider parameter required", http.StatusBadRequest)
        }</span>

        <span class="cov8" title="1">config, exists := m.providers[providerName]
        if !exists </span><span class="cov8" title="1">{
                return m.sendAuthenticationError(c, "PROVIDER_NOT_FOUND", fmt.Sprintf("Provider %s not configured", providerName), http.StatusBadRequest)
        }</span>

        // Get authorization code
        <span class="cov8" title="1">code := c.Query("code")
        if code == "" </span><span class="cov8" title="1">{
                errorDesc := c.Query("error_description")
                if errorDesc == "" </span><span class="cov8" title="1">{
                        errorDesc = "Authorization code not received"
                }</span>
                <span class="cov8" title="1">return m.sendAuthenticationError(c, "AUTHORIZATION_FAILED", errorDesc, http.StatusBadRequest)</span>
        }

        // Exchange code for token
        <span class="cov8" title="1">ctx := context.Background()
        token, err := config.OAuth2Config.Exchange(ctx, code)
        if err != nil </span><span class="cov0" title="0">{
                return m.sendAuthenticationError(c, "TOKEN_EXCHANGE_FAILED", "Failed to exchange authorization code for token", http.StatusInternalServerError)
        }</span>

        // Extract ID token
        <span class="cov8" title="1">rawIDToken, ok := token.Extra("id_token").(string)
        if !ok </span><span class="cov0" title="0">{
                return m.sendAuthenticationError(c, "MISSING_ID_TOKEN", "ID token not found in response", http.StatusInternalServerError)
        }</span>

        // Verify ID token
        <span class="cov8" title="1">idToken, err := config.Verifier.Verify(ctx, rawIDToken)
        if err != nil </span><span class="cov8" title="1">{
                return m.sendAuthenticationError(c, "TOKEN_VERIFICATION_FAILED", "Failed to verify ID token", http.StatusInternalServerError)
        }</span>

        // Extract claims
        <span class="cov0" title="0">var claims map[string]interface{}
        if err := idToken.Claims(&amp;claims); err != nil </span><span class="cov0" title="0">{
                return m.sendAuthenticationError(c, "CLAIMS_EXTRACTION_FAILED", "Failed to extract claims from ID token", http.StatusInternalServerError)
        }</span>

        // Create user session
        <span class="cov0" title="0">userID, ok := claims["sub"].(string)
        if !ok || userID == "" </span><span class="cov0" title="0">{
                return m.sendAuthenticationError(c, "INVALID_USER_ID", "User ID (sub) not found in token claims", http.StatusInternalServerError)
        }</span>

        <span class="cov0" title="0">email, _ := claims["email"].(string)
        name, _ := claims["name"].(string)

        // Generate JWT token for the session
        jwtToken, err := m.jwtService.GenerateToken(userID, email, name)
        if err != nil </span><span class="cov0" title="0">{
                return m.sendAuthenticationError(c, "JWT_GENERATION_FAILED", "Failed to generate session token", http.StatusInternalServerError)
        }</span>

        // Return successful authentication response
        <span class="cov0" title="0">return c.JSON(fiber.Map{
                "success": true,
                "token":   jwtToken,
                "user": fiber.Map{
                        "id":    userID,
                        "email": email,
                        "name":  name,
                },
                "expires_at": time.Now().Add(8 * time.Hour).Unix(), // Default 8 hour expiration
        })</span>
}

// ListProviders returns available authentication providers
func (m *AuthMiddleware) ListProviders() fiber.Handler <span class="cov8" title="1">{
        return func(c fiber.Ctx) error </span><span class="cov8" title="1">{
                providers := make([]fiber.Map, 0, len(m.providers))
                for name, config := range m.providers </span><span class="cov8" title="1">{
                        providers = append(providers, fiber.Map{
                                "name":   name,
                                "issuer": config.Settings.Issuer,
                                "scopes": config.Settings.Scopes,
                        })
                }</span>

                <span class="cov8" title="1">return c.JSON(fiber.Map{
                        "providers": providers,
                })</span>
        }
}

// GetProviders returns the list of configured provider names
func (m *AuthMiddleware) GetProviders() []string <span class="cov8" title="1">{
        providers := make([]string, 0, len(m.providers))
        for name := range m.providers </span><span class="cov8" title="1">{
                providers = append(providers, name)
        }</span>
        <span class="cov8" title="1">return providers</span>
}


// sendAuthenticationError sends a standardized authentication error response
func (m *AuthMiddleware) sendAuthenticationError(c fiber.Ctx, code, message string, statusCode int) error <span class="cov8" title="1">{
        // Log the error (structured logging would be used in production)
        fmt.Printf("Authentication error: %s - %s\n", code, message)

        return c.Status(statusCode).JSON(fiber.Map{
                "error":   true,
                "code":    code,
                "message": message,
        })
}</span>

// ValidateProviderConfiguration validates that a provider configuration is complete
func ValidateProviderConfiguration(provider OIDCProvider) error <span class="cov8" title="1">{
        if provider.Name == "" </span><span class="cov8" title="1">{
                return &amp;AuthenticationError{Code: "INVALID_CONFIG", Message: "Provider name is required"}
        }</span>
        <span class="cov8" title="1">if provider.Issuer == "" </span><span class="cov8" title="1">{
                return &amp;AuthenticationError{Code: "INVALID_CONFIG", Message: "Provider issuer is required"}
        }</span>
        <span class="cov8" title="1">if provider.ClientID == "" </span><span class="cov8" title="1">{
                return &amp;AuthenticationError{Code: "INVALID_CONFIG", Message: "Client ID is required"}
        }</span>
        <span class="cov8" title="1">if provider.ClientSecret == "" </span><span class="cov8" title="1">{
                return &amp;AuthenticationError{Code: "INVALID_CONFIG", Message: "Client secret is required"}
        }</span>
        <span class="cov8" title="1">if provider.RedirectURL == "" </span><span class="cov8" title="1">{
                return &amp;AuthenticationError{Code: "INVALID_CONFIG", Message: "Redirect URL is required"}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetSupportedProviders returns a list of pre-configured provider templates
func GetSupportedProviders() map[string]OIDCProvider <span class="cov8" title="1">{
        return map[string]OIDCProvider{
                "okta": {
                        Name:   "okta",
                        Scopes: []string{"email", "profile", "groups"},
                        ExtraParams: map[string]string{
                                "prompt": "login", // Force MFA
                        },
                },
                "auth0": {
                        Name:   "auth0",
                        Scopes: []string{"email", "profile"},
                        ExtraParams: map[string]string{
                                "prompt": "login",
                        },
                },
                "azure": {
                        Name:   "azure",
                        Scopes: []string{"email", "profile", "User.Read"},
                        ExtraParams: map[string]string{
                                "prompt": "login",
                        },
                },
                "google": {
                        Name:   "google",
                        Issuer: "https://accounts.google.com",
                        Scopes: []string{"email", "profile"},
                        ExtraParams: map[string]string{
                                "prompt": "select_account consent",
                        },
                },
        }
}</pre>
		
		<pre class="file" id="file1" style="display: none">package middleware

import (
        "fmt"
        "sync"
        "time"
)

// CircuitBreakerState represents the state of the circuit breaker
type CircuitBreakerState int

const (
        StateClosed CircuitBreakerState = iota
        StateOpen
        StateHalfOpen
)

// CircuitBreakerConfig holds configuration for the circuit breaker
type CircuitBreakerConfig struct {
        FailureThreshold   int           `json:"failure_threshold"`    // Number of failures to trigger open state
        SuccessThreshold   int           `json:"success_threshold"`    // Number of successes to close from half-open
        Timeout            time.Duration `json:"timeout"`              // Time to wait before transitioning to half-open
        MaxRequests        int           `json:"max_requests"`         // Max requests allowed in half-open state
        OnStateChange      func(CircuitBreakerState) `json:"-"`       // Callback for state changes
}

// CircuitBreaker implements the circuit breaker pattern for external service calls
type CircuitBreaker struct {
        config           CircuitBreakerConfig
        state            CircuitBreakerState
        failureCount     int
        successCount     int
        requestCount     int
        lastFailureTime  time.Time
        mu               sync.RWMutex
}

// CircuitBreakerError represents errors from circuit breaker
type CircuitBreakerError struct {
        State   CircuitBreakerState `json:"state"`
        Message string             `json:"message"`
}

func (e *CircuitBreakerError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("circuit breaker %s: %s", e.stateString(), e.Message)
}</span>

func (e *CircuitBreakerError) stateString() string <span class="cov8" title="1">{
        switch e.State </span>{
        case StateClosed:<span class="cov8" title="1">
                return "closed"</span>
        case StateOpen:<span class="cov8" title="1">
                return "open"</span>
        case StateHalfOpen:<span class="cov8" title="1">
                return "half-open"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// NewCircuitBreaker creates a new circuit breaker with the given configuration
func NewCircuitBreaker(config CircuitBreakerConfig) *CircuitBreaker <span class="cov8" title="1">{
        // Set defaults
        if config.FailureThreshold == 0 </span><span class="cov8" title="1">{
                config.FailureThreshold = 5
        }</span>
        <span class="cov8" title="1">if config.SuccessThreshold == 0 </span><span class="cov8" title="1">{
                config.SuccessThreshold = 2
        }</span>
        <span class="cov8" title="1">if config.Timeout == 0 </span><span class="cov8" title="1">{
                config.Timeout = 30 * time.Second
        }</span>
        <span class="cov8" title="1">if config.MaxRequests == 0 </span><span class="cov8" title="1">{
                config.MaxRequests = 10
        }</span>

        <span class="cov8" title="1">return &amp;CircuitBreaker{
                config:          config,
                state:           StateClosed,
                failureCount:    0,
                successCount:    0,
                requestCount:    0,
                lastFailureTime: time.Now(),
        }</span>
}

// Execute runs a function with circuit breaker protection
func (cb *CircuitBreaker) Execute(fn func() error) error <span class="cov8" title="1">{
        // Check if we can execute the request
        if !cb.canExecute() </span><span class="cov8" title="1">{
                return &amp;CircuitBreakerError{
                        State:   cb.getState(),
                        Message: "circuit breaker is open",
                }
        }</span>

        // Execute the function
        <span class="cov8" title="1">err := fn()

        // Handle the result
        if err != nil </span><span class="cov8" title="1">{
                cb.onFailure()
                return err
        }</span>

        <span class="cov8" title="1">cb.onSuccess()
        return nil</span>
}

// canExecute determines if a request can be executed based on circuit breaker state
func (cb *CircuitBreaker) canExecute() bool <span class="cov8" title="1">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        switch cb.state </span>{
        case StateClosed:<span class="cov8" title="1">
                return true</span>
        case StateOpen:<span class="cov8" title="1">
                // Check if timeout has passed to move to half-open
                if time.Since(cb.lastFailureTime) &gt; cb.config.Timeout </span><span class="cov8" title="1">{
                        cb.setState(StateHalfOpen)
                        return true
                }</span>
                <span class="cov8" title="1">return false</span>
        case StateHalfOpen:<span class="cov8" title="1">
                // Allow limited requests in half-open state
                return cb.requestCount &lt; cb.config.MaxRequests</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// onSuccess handles successful execution
func (cb *CircuitBreaker) onSuccess() <span class="cov8" title="1">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        switch cb.state </span>{
        case StateClosed:<span class="cov8" title="1">
                // Reset failure count on success
                cb.failureCount = 0</span>
        case StateHalfOpen:<span class="cov8" title="1">
                cb.successCount++
                cb.requestCount++
                
                // Close circuit if we have enough successes
                if cb.successCount &gt;= cb.config.SuccessThreshold </span><span class="cov8" title="1">{
                        cb.setState(StateClosed)
                        cb.reset()
                }</span>
        }
}

// onFailure handles failed execution
func (cb *CircuitBreaker) onFailure() <span class="cov8" title="1">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        cb.failureCount++
        cb.lastFailureTime = time.Now()

        switch cb.state </span>{
        case StateClosed:<span class="cov8" title="1">
                // Open circuit if failure threshold is reached
                if cb.failureCount &gt;= cb.config.FailureThreshold </span><span class="cov8" title="1">{
                        cb.setState(StateOpen)
                }</span>
        case StateHalfOpen:<span class="cov0" title="0">
                // Go back to open on any failure in half-open state
                cb.setState(StateOpen)
                cb.requestCount = 0
                cb.successCount = 0</span>
        }
}

// setState changes the circuit breaker state and calls the callback if configured
func (cb *CircuitBreaker) setState(state CircuitBreakerState) <span class="cov8" title="1">{
        if cb.state != state </span><span class="cov8" title="1">{
                cb.state = state
                if cb.config.OnStateChange != nil </span><span class="cov8" title="1">{
                        cb.config.OnStateChange(state)
                }</span>
        }
}

// getState returns the current circuit breaker state (thread-safe)
func (cb *CircuitBreaker) getState() CircuitBreakerState <span class="cov8" title="1">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()
        return cb.state
}</span>

// reset clears counters and resets the circuit breaker state
func (cb *CircuitBreaker) reset() <span class="cov8" title="1">{
        cb.failureCount = 0
        cb.successCount = 0
        cb.requestCount = 0
}</span>

// GetMetrics returns current metrics for monitoring
func (cb *CircuitBreaker) GetMetrics() map[string]interface{} <span class="cov8" title="1">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()

        return map[string]interface{}{
                "state":                cb.state,
                "failure_count":        cb.failureCount,
                "success_count":        cb.successCount,
                "request_count":        cb.requestCount,
                "last_failure_time":    cb.lastFailureTime,
                "failure_threshold":    cb.config.FailureThreshold,
                "success_threshold":    cb.config.SuccessThreshold,
                "timeout":              cb.config.Timeout,
                "max_requests":         cb.config.MaxRequests,
        }
}</span>

// IsOpen returns true if the circuit breaker is in open state
func (cb *CircuitBreaker) IsOpen() bool <span class="cov8" title="1">{
        return cb.getState() == StateOpen
}</span>

// IsClosed returns true if the circuit breaker is in closed state
func (cb *CircuitBreaker) IsClosed() bool <span class="cov8" title="1">{
        return cb.getState() == StateClosed
}</span>

// IsHalfOpen returns true if the circuit breaker is in half-open state
func (cb *CircuitBreaker) IsHalfOpen() bool <span class="cov8" title="1">{
        return cb.getState() == StateHalfOpen
}</span>

// ForceOpen forces the circuit breaker to open state
func (cb *CircuitBreaker) ForceOpen() <span class="cov8" title="1">{
        cb.mu.Lock()
        defer cb.mu.Unlock()
        cb.setState(StateOpen)
}</span>

// ForceClose forces the circuit breaker to closed state
func (cb *CircuitBreaker) ForceClose() <span class="cov8" title="1">{
        cb.mu.Lock()
        defer cb.mu.Unlock()
        cb.setState(StateClosed)
        cb.reset()
}</pre>
		
		<pre class="file" id="file2" style="display: none">// Package middleware provides JWT token management for secure authentication
package middleware

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/base64"
        "encoding/json"
        "encoding/pem"
        "fmt"
        "time"

        "github.com/go-redis/redis/v8"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "golang.org/x/net/context"
)

// JWTClaims represents the claims stored in JWT tokens
type JWTClaims struct {
        UserID    string    `json:"user_id"`
        Email     string    `json:"email"`
        Name      string    `json:"name"`
        SessionID string    `json:"session_id"`
        Role      string    `json:"role,omitempty"`
        Groups    []string  `json:"groups,omitempty"`
        IssuedAt  time.Time `json:"iat"`
        ExpiresAt time.Time `json:"exp"`
        jwt.RegisteredClaims
}

// JWTServiceInterface defines the contract for JWT token operations
type JWTServiceInterface interface {
        GenerateToken(userID, email, name string) (*TokenPair, error)
        ValidateToken(tokenString string) (*JWTClaims, error)
        RefreshToken(refreshToken string) (*TokenPair, error)
        BlacklistToken(sessionID string) error
        CleanupExpiredSessions() error
        GetPublicKey() *rsa.PublicKey
        GetPublicKeyPEM() (string, error)
}

// JWTService handles JWT token generation, validation, and management
type JWTService struct {
        privateKey     *rsa.PrivateKey
        publicKey      *rsa.PublicKey
        redisClient    redis.UniversalClient
        tokenDuration  time.Duration
        refreshDuration time.Duration
        issuer         string
}

// JWTConfig holds configuration for JWT service
type JWTConfig struct {
        PrivateKeyPEM        string        `json:"private_key_pem"`
        RedisAddr            string        `json:"redis_addr"`         // Redis server address (single instance)
        RedisCluster         []string      `json:"redis_cluster"`      // Redis cluster addresses
        RedisPassword        string        `json:"redis_password"`     // Redis password
        RedisDB              int           `json:"redis_db"`           // Redis database number
        TokenDuration        time.Duration `json:"token_duration"`     // Access token lifetime
        RefreshDuration      time.Duration `json:"refresh_duration"`   // Refresh token lifetime
        Issuer               string        `json:"issuer"`             // JWT issuer
        PoolSize             int           `json:"pool_size"`          // Redis connection pool size
        MinIdleConns         int           `json:"min_idle_conns"`     // Minimum idle connections
        MaxRetries           int           `json:"max_retries"`        // Maximum retry attempts
        RetryDelay           time.Duration `json:"retry_delay"`        // Delay between retries
        DialTimeout          time.Duration `json:"dial_timeout"`       // Connection dial timeout
        ReadTimeout          time.Duration `json:"read_timeout"`       // Read operation timeout
        WriteTimeout         time.Duration `json:"write_timeout"`      // Write operation timeout
        EnableCircuitBreaker bool          `json:"enable_circuit_breaker"` // Enable circuit breaker for Redis failures
}

// TokenPair represents access and refresh tokens
type TokenPair struct {
        AccessToken  string    `json:"access_token"`
        RefreshToken string    `json:"refresh_token"`
        ExpiresAt    time.Time `json:"expires_at"`
        TokenType    string    `json:"token_type"`
}

// TokenValidationError represents JWT validation errors
type TokenValidationError struct {
        Code    string `json:"code"`
        Message string `json:"message"`
}

func (e *TokenValidationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("Token validation error [%s]: %s", e.Code, e.Message)
}</span>

// NewJWTService creates a new JWT service instance
func NewJWTService(config JWTConfig) (*JWTService, error) <span class="cov8" title="1">{
        // Parse private key
        var privateKey *rsa.PrivateKey
        var publicKey *rsa.PublicKey

        if config.PrivateKeyPEM != "" </span><span class="cov0" title="0">{
                // Use provided private key
                key, err := parsePrivateKey(config.PrivateKeyPEM)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse private key: %w", err)
                }</span>
                <span class="cov0" title="0">privateKey = key
                publicKey = &amp;key.PublicKey</span>
        } else<span class="cov8" title="1"> {
                // Generate new key pair
                key, err := generateKeyPair()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate key pair: %w", err)
                }</span>
                <span class="cov8" title="1">privateKey = key
                publicKey = &amp;key.PublicKey</span>
        }

        // Initialize Redis client with enhanced configuration
        <span class="cov8" title="1">var redisAddrs []string
        if len(config.RedisCluster) &gt; 0 </span><span class="cov0" title="0">{
                // Use cluster addresses
                redisAddrs = config.RedisCluster
        }</span> else<span class="cov8" title="1"> if config.RedisAddr != "" </span><span class="cov8" title="1">{
                // Use single instance
                redisAddrs = []string{config.RedisAddr}
        }</span> else<span class="cov0" title="0"> {
                // Default fallback
                redisAddrs = []string{"localhost:6379"}
        }</span>

        // Set performance defaults
        <span class="cov8" title="1">poolSize := config.PoolSize
        if poolSize == 0 </span><span class="cov8" title="1">{
                poolSize = 10 // Default pool size
        }</span>
        
        <span class="cov8" title="1">minIdleConns := config.MinIdleConns
        if minIdleConns == 0 </span><span class="cov8" title="1">{
                minIdleConns = 2 // Default minimum idle connections
        }</span>

        <span class="cov8" title="1">maxRetries := config.MaxRetries
        if maxRetries == 0 </span><span class="cov8" title="1">{
                maxRetries = 3 // Default max retries
        }</span>

        <span class="cov8" title="1">dialTimeout := config.DialTimeout
        if dialTimeout == 0 </span><span class="cov8" title="1">{
                dialTimeout = 5 * time.Second // Default dial timeout
        }</span>

        <span class="cov8" title="1">readTimeout := config.ReadTimeout
        if readTimeout == 0 </span><span class="cov8" title="1">{
                readTimeout = 3 * time.Second // Default read timeout
        }</span>

        <span class="cov8" title="1">writeTimeout := config.WriteTimeout
        if writeTimeout == 0 </span><span class="cov8" title="1">{
                writeTimeout = 3 * time.Second // Default write timeout
        }</span>

        <span class="cov8" title="1">redisClient := redis.NewUniversalClient(&amp;redis.UniversalOptions{
                Addrs:        redisAddrs,
                Password:     config.RedisPassword,
                DB:           config.RedisDB,
                PoolSize:     poolSize,
                MinIdleConns: minIdleConns,
                MaxRetries:  maxRetries,
                DialTimeout: dialTimeout,
                ReadTimeout:  readTimeout,
                WriteTimeout: writeTimeout,
        })

        // Test Redis connection
        ctx := context.Background()
        if err := redisClient.Ping(ctx).Err(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to connect to Redis: %w", err)
        }</span>

        // Set default durations
        <span class="cov0" title="0">tokenDuration := config.TokenDuration
        if tokenDuration == 0 </span><span class="cov0" title="0">{
                tokenDuration = 8 * time.Hour // Default 8 hours as per requirements
        }</span>

        <span class="cov0" title="0">refreshDuration := config.RefreshDuration
        if refreshDuration == 0 </span><span class="cov0" title="0">{
                refreshDuration = 24 * time.Hour * 7 // Default 7 days
        }</span>

        <span class="cov0" title="0">issuer := config.Issuer
        if issuer == "" </span><span class="cov0" title="0">{
                issuer = "kubechat-api"
        }</span>

        <span class="cov0" title="0">return &amp;JWTService{
                privateKey:      privateKey,
                publicKey:       publicKey,
                redisClient:     redisClient,
                tokenDuration:   tokenDuration,
                refreshDuration: refreshDuration,
                issuer:          issuer,
        }, nil</span>
}

// GenerateToken creates a new JWT token for the user
func (j *JWTService) GenerateToken(userID, email, name string) (*TokenPair, error) <span class="cov8" title="1">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, &amp;TokenValidationError{
                        Code:    "INVALID_USER_ID",
                        Message: "User ID is required for token generation",
                }
        }</span>

        <span class="cov8" title="1">sessionID := uuid.New().String()
        now := time.Now()
        expiresAt := now.Add(j.tokenDuration)

        // Create JWT claims
        claims := &amp;JWTClaims{
                UserID:    userID,
                Email:     email,
                Name:      name,
                SessionID: sessionID,
                IssuedAt:  now,
                ExpiresAt: expiresAt,
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    j.issuer,
                        Subject:   userID,
                        ID:        sessionID,
                        IssuedAt:  jwt.NewNumericDate(now),
                        ExpiresAt: jwt.NewNumericDate(expiresAt),
                },
        }

        // Create token
        token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
        accessToken, err := token.SignedString(j.privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign token: %w", err)
        }</span>

        // Generate refresh token
        <span class="cov8" title="1">refreshToken := uuid.New().String()
        refreshExpiresAt := now.Add(j.refreshDuration)

        // Store session in Redis
        sessionData := map[string]interface{}{
                "user_id":            userID,
                "email":              email,
                "name":               name,
                "session_id":         sessionID,
                "refresh_token":      refreshToken,
                "created_at":         now.Unix(),
                "expires_at":         expiresAt.Unix(),
                "refresh_expires_at": refreshExpiresAt.Unix(),
                "active":             true,
        }

        sessionJSON, err := json.Marshal(sessionData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal session data: %w", err)
        }</span>

        // Store session data only if Redis is available
        <span class="cov8" title="1">if j.redisClient != nil </span><span class="cov0" title="0">{
                ctx := context.Background()
                
                // Store session data with expiration
                if err := j.redisClient.Set(ctx, j.sessionKey(sessionID), sessionJSON, j.refreshDuration).Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to store session in Redis: %w", err)
                }</span>

                // Store refresh token mapping
                <span class="cov0" title="0">if err := j.redisClient.Set(ctx, j.refreshKey(refreshToken), sessionID, j.refreshDuration).Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to store refresh token in Redis: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return &amp;TokenPair{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                ExpiresAt:    expiresAt,
                TokenType:    "Bearer",
        }, nil</span>
}

// ValidateToken validates and parses a JWT token
func (j *JWTService) ValidateToken(tokenString string) (*JWTClaims, error) <span class="cov8" title="1">{
        // Parse token
        token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                // Verify signing method
                if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok </span><span class="cov0" title="0">{
                        return nil, &amp;TokenValidationError{
                                Code:    "INVALID_SIGNING_METHOD",
                                Message: fmt.Sprintf("Unexpected signing method: %v", token.Header["alg"]),
                        }
                }</span>
                <span class="cov8" title="1">return j.publicKey, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;TokenValidationError{
                        Code:    "TOKEN_PARSE_ERROR",
                        Message: "Failed to parse token",
                }
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(*JWTClaims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, &amp;TokenValidationError{
                        Code:    "INVALID_TOKEN",
                        Message: "Token is invalid",
                }
        }</span>

        // Check if session is still active in Redis (if available)
        <span class="cov8" title="1">if j.redisClient != nil </span><span class="cov0" title="0">{
                ctx := context.Background()
                sessionData, err := j.redisClient.Get(ctx, j.sessionKey(claims.SessionID)).Result()
                if err != nil </span><span class="cov0" title="0">{
                        if err == redis.Nil </span><span class="cov0" title="0">{
                                return nil, &amp;TokenValidationError{
                                        Code:    "SESSION_NOT_FOUND",
                                        Message: "Session not found or expired",
                                }
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to check session in Redis: %w", err)</span>
                }

                // Parse session data to verify it's active
                <span class="cov0" title="0">var session map[string]interface{}
                if err := json.Unmarshal([]byte(sessionData), &amp;session); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse session data: %w", err)
                }</span>
                
                <span class="cov0" title="0">if active, ok := session["active"].(bool); !ok || !active </span><span class="cov0" title="0">{
                        return nil, &amp;TokenValidationError{
                                Code:    "SESSION_INACTIVE",
                                Message: "Session is no longer active",
                        }
                }</span>
        }

        <span class="cov8" title="1">return claims, nil</span>
}

// RefreshToken creates a new token pair using a refresh token
func (j *JWTService) RefreshToken(refreshToken string) (*TokenPair, error) <span class="cov8" title="1">{
        if refreshToken == "" </span><span class="cov8" title="1">{
                return nil, &amp;TokenValidationError{
                        Code:    "INVALID_REFRESH_TOKEN",
                        Message: "Refresh token cannot be empty",
                }
        }</span>

        <span class="cov8" title="1">if j.redisClient == nil </span><span class="cov8" title="1">{
                return nil, &amp;TokenValidationError{
                        Code:    "SERVICE_UNAVAILABLE",
                        Message: "Redis client not available for refresh tokens",
                }
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        // Get session ID from refresh token
        sessionID, err := j.redisClient.Get(ctx, j.refreshKey(refreshToken)).Result()
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        return nil, &amp;TokenValidationError{
                                Code:    "INVALID_REFRESH_TOKEN",
                                Message: "Refresh token not found or expired",
                        }
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to lookup refresh token: %w", err)</span>
        }

        // Get session data
        <span class="cov0" title="0">sessionData, err := j.redisClient.Get(ctx, j.sessionKey(sessionID)).Result()
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        return nil, &amp;TokenValidationError{
                                Code:    "SESSION_NOT_FOUND",
                                Message: "Session not found or expired",
                        }
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get session data: %w", err)</span>
        }

        <span class="cov0" title="0">var session map[string]interface{}
        if err := json.Unmarshal([]byte(sessionData), &amp;session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse session data: %w", err)
        }</span>

        // Extract user information
        <span class="cov0" title="0">userID, _ := session["user_id"].(string)
        email, _ := session["email"].(string)
        name, _ := session["name"].(string)

        if userID == "" </span><span class="cov0" title="0">{
                return nil, &amp;TokenValidationError{
                        Code:    "INVALID_SESSION",
                        Message: "Invalid session data",
                }
        }</span>

        // Invalidate old refresh token
        <span class="cov0" title="0">if err := j.redisClient.Del(ctx, j.refreshKey(refreshToken)).Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to invalidate old refresh token: %w", err)
        }</span>

        // Generate new token pair
        <span class="cov0" title="0">return j.GenerateToken(userID, email, name)</span>
}

// BlacklistToken adds a token to the blacklist
func (j *JWTService) BlacklistToken(sessionID string) error <span class="cov8" title="1">{
        if j.redisClient == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Redis client not available for blacklisting tokens")
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        // Get session data to find refresh token
        sessionData, err := j.redisClient.Get(ctx, j.sessionKey(sessionID)).Result()
        if err != nil &amp;&amp; err != redis.Nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get session data: %w", err)
        }</span>

        // Mark session as inactive
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                var session map[string]interface{}
                if err := json.Unmarshal([]byte(sessionData), &amp;session); err == nil </span><span class="cov0" title="0">{
                        session["active"] = false
                        updatedData, _ := json.Marshal(session)
                        j.redisClient.Set(ctx, j.sessionKey(sessionID), updatedData, time.Hour) // Keep for audit

                        // Remove refresh token if it exists
                        if refreshToken, ok := session["refresh_token"].(string); ok </span><span class="cov0" title="0">{
                                j.redisClient.Del(ctx, j.refreshKey(refreshToken))
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// CleanupExpiredSessions removes expired sessions from Redis
func (j *JWTService) CleanupExpiredSessions() error <span class="cov8" title="1">{
        if j.redisClient == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Redis client not available for session cleanup")
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        // This would typically be run as a background job
        // For now, we rely on Redis TTL for cleanup
        
        // Get all session keys
        keys, err := j.redisClient.Keys(ctx, "kubechat:session:*").Result()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get session keys: %w", err)
        }</span>

        <span class="cov0" title="0">now := time.Now().Unix()
        
        for _, key := range keys </span><span class="cov0" title="0">{
                sessionData, err := j.redisClient.Get(ctx, key).Result()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var session map[string]interface{}
                if err := json.Unmarshal([]byte(sessionData), &amp;session); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if expiresAt, ok := session["expires_at"].(float64); ok </span><span class="cov0" title="0">{
                        if int64(expiresAt) &lt; now </span><span class="cov0" title="0">{
                                j.redisClient.Del(ctx, key)
                                
                                // Also remove refresh token
                                if refreshToken, ok := session["refresh_token"].(string); ok </span><span class="cov0" title="0">{
                                        j.redisClient.Del(ctx, j.refreshKey(refreshToken))
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// GetPublicKey returns the RSA public key for token verification
func (j *JWTService) GetPublicKey() *rsa.PublicKey <span class="cov8" title="1">{
        return j.publicKey
}</span>

// GetPublicKeyPEM returns the public key in PEM format
func (j *JWTService) GetPublicKeyPEM() (string, error) <span class="cov8" title="1">{
        publicKeyDER, err := x509.MarshalPKIXPublicKey(j.publicKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal public key: %w", err)
        }</span>

        <span class="cov8" title="1">publicKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "PUBLIC KEY",
                Bytes: publicKeyDER,
        })

        return string(publicKeyPEM), nil</span>
}

// Helper functions

func (j *JWTService) sessionKey(sessionID string) string <span class="cov0" title="0">{
        return fmt.Sprintf("kubechat:session:%s", sessionID)
}</span>

func (j *JWTService) refreshKey(refreshToken string) string <span class="cov0" title="0">{
        return fmt.Sprintf("kubechat:refresh:%s", refreshToken)
}</span>

func parsePrivateKey(privateKeyPEM string) (*rsa.PrivateKey, error) <span class="cov8" title="1">{
        block, _ := pem.Decode([]byte(privateKeyPEM))
        if block == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse PEM block")
        }</span>

        <span class="cov8" title="1">key, err := x509.ParsePKCS1PrivateKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                // Try PKCS8 format
                keyInterface, err := x509.ParsePKCS8PrivateKey(block.Bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse private key: %w", err)
                }</span>
                <span class="cov0" title="0">var ok bool
                key, ok = keyInterface.(*rsa.PrivateKey)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("not an RSA private key")
                }</span>
        }

        <span class="cov8" title="1">return key, nil</span>
}

func generateKeyPair() (*rsa.PrivateKey, error) <span class="cov8" title="1">{
        return rsa.GenerateKey(rand.Reader, 2048)
}</span>

// EncodePrivateKeyToPEM encodes an RSA private key to PEM format
func EncodePrivateKeyToPEM(privateKey *rsa.PrivateKey) string <span class="cov8" title="1">{
        privateKeyDER := x509.MarshalPKCS1PrivateKey(privateKey)
        privateKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: privateKeyDER,
        })
        return string(privateKeyPEM)
}</span>

// GenerateSecretKey generates a base64-encoded secret key for HMAC
func GenerateSecretKey() (string, error) <span class="cov8" title="1">{
        key := make([]byte, 32)
        _, err := rand.Read(key)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return base64.StdEncoding.EncodeToString(key), nil</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">// Package middleware provides SAML authentication fallback for legacy enterprise systems
package middleware

import (
        "context"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "encoding/xml"
        "fmt"
        "net/http"
        "net/url"
        "time"

        "github.com/crewjam/saml"
        "github.com/crewjam/saml/samlsp"
        "github.com/gofiber/fiber/v3"
)

// SAMLConfig holds configuration for SAML authentication
type SAMLConfig struct {
        EntityID          string `json:"entity_id"`           // Service Provider Entity ID
        ACSURL           string `json:"acs_url"`             // Assertion Consumer Service URL
        SLOUrl           string `json:"slo_url"`             // Single Logout URL
        IDPMetadataURL   string `json:"idp_metadata_url"`    // Identity Provider metadata URL
        IDPMetadataXML   string `json:"idp_metadata_xml"`    // Alternative: raw IDP metadata XML
        PrivateKeyPEM    string `json:"private_key_pem"`     // Private key for signing
        CertificatePEM   string `json:"certificate_pem"`     // Certificate for signing
        SignRequests     bool   `json:"sign_requests"`       // Whether to sign SAML requests
        ForceAuthn       bool   `json:"force_authn"`         // Force re-authentication
        AllowIDPInit     bool   `json:"allow_idp_init"`      // Allow IDP-initiated login
}

// SAMLProvider manages SAML authentication
type SAMLProvider struct {
        config         SAMLConfig
        jwtService     JWTServiceInterface
        serviceProvider *samlsp.Middleware
}

// SAMLAssertion represents processed SAML assertion data
type SAMLAssertion struct {
        Subject       string                 `json:"subject"`
        NameID        string                 `json:"name_id"`
        Email         string                 `json:"email"`
        DisplayName   string                 `json:"display_name"`
        GivenName     string                 `json:"given_name"`
        Surname       string                 `json:"surname"`
        Groups        []string               `json:"groups"`
        Attributes    map[string]interface{} `json:"attributes"`
        SessionIndex  string                 `json:"session_index"`
        NotOnOrAfter  time.Time             `json:"not_on_or_after"`
}

// SAMLError represents SAML-specific errors
type SAMLError struct {
        Code    string `json:"code"`
        Message string `json:"message"`
        Details string `json:"details,omitempty"`
}

func (e *SAMLError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("SAML error [%s]: %s", e.Code, e.Message)
}</span>

// NewSAMLProvider creates a new SAML authentication provider
func NewSAMLProvider(config SAMLConfig, jwtService JWTServiceInterface) (*SAMLProvider, error) <span class="cov8" title="1">{
        if err := validateSAMLConfig(config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid SAML configuration: %w", err)
        }</span>

        // Parse and validate entity ID URL
        <span class="cov8" title="1">rootURL, err := url.Parse(config.EntityID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, &amp;SAMLError{
                        Code:    "INVALID_ENTITY_ID",
                        Message: "Entity ID must be a valid URL",
                        Details: err.Error(),
                }
        }</span>

        // Create SAML Service Provider options
        <span class="cov8" title="1">samlOptions := samlsp.Options{
                URL:          *rootURL,
                Key:          nil, // Will be set if provided
                Certificate:  nil, // Will be set if provided
                EntityID:     config.EntityID,
        }

        // Parse signing credentials if provided
        if config.PrivateKeyPEM != "" &amp;&amp; config.CertificatePEM != "" </span><span class="cov0" title="0">{
                privateKey, certificate, err := parseCertificateAndKey(config.PrivateKeyPEM, config.CertificatePEM)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse SAML signing credentials: %w", err)
                }</span>
                <span class="cov0" title="0">samlOptions.Key = privateKey
                samlOptions.Certificate = certificate</span>
        }

        // Load IDP metadata
        <span class="cov8" title="1">var idpMetadata *saml.EntityDescriptor
        if config.IDPMetadataURL != "" </span><span class="cov0" title="0">{
                // Fetch metadata from URL
                metadataURL, err := url.Parse(config.IDPMetadataURL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, &amp;SAMLError{
                                Code:    "INVALID_METADATA_URL",
                                Message: "Invalid IDP metadata URL",
                                Details: err.Error(),
                        }
                }</span>

                <span class="cov0" title="0">ctx := context.Background()
                idpMetadata, err = samlsp.FetchMetadata(ctx, http.DefaultClient, *metadataURL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, &amp;SAMLError{
                                Code:    "METADATA_PARSE_FAILED",
                                Message: "Failed to fetch and parse IDP metadata",
                                Details: err.Error(),
                        }
                }</span>
        } else<span class="cov8" title="1"> if config.IDPMetadataXML != "" </span><span class="cov8" title="1">{
                // Parse metadata from XML string
                var err error
                idpMetadata, err = samlsp.ParseMetadata([]byte(config.IDPMetadataXML))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, &amp;SAMLError{
                                Code:    "METADATA_PARSE_FAILED",
                                Message: "Failed to parse IDP metadata XML",
                                Details: err.Error(),
                        }
                }</span>
        } else<span class="cov0" title="0"> {
                return nil, &amp;SAMLError{
                        Code:    "NO_IDP_METADATA",
                        Message: "Either IDP metadata URL or XML must be provided",
                }
        }</span>

        <span class="cov8" title="1">samlOptions.IDPMetadata = idpMetadata

        // Create the SAML service provider middleware
        serviceProvider, err := samlsp.New(samlOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;SAMLError{
                        Code:    "SP_CREATION_FAILED",
                        Message: "Failed to create SAML service provider",
                        Details: err.Error(),
                }
        }</span>

        <span class="cov8" title="1">return &amp;SAMLProvider{
                config:          config,
                jwtService:      jwtService,
                serviceProvider: serviceProvider,
        }, nil</span>
}

// GetMetadata returns the SAML service provider metadata
func (sp *SAMLProvider) GetMetadata() fiber.Handler <span class="cov0" title="0">{
        return func(c fiber.Ctx) error </span><span class="cov0" title="0">{
                // Generate mock metadata for testing
                metadata := fmt.Sprintf(`&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;EntityDescriptor entityID="%s" xmlns="urn:oasis:names:tc:SAML:2.0:metadata"&gt;
  &lt;SPSSODescriptor protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol"&gt;
    &lt;AssertionConsumerService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST" Location="%s" index="0"/&gt;
  &lt;/SPSSODescriptor&gt;
&lt;/EntityDescriptor&gt;`, sp.config.EntityID, sp.config.ACSURL)
                
                c.Set("Content-Type", "application/samlmetadata+xml")
                return c.Send([]byte(metadata))
        }</span>
}

// GetAuthURL returns the SAML authentication URL
func (sp *SAMLProvider) GetAuthURL(relayState string) (string, error) <span class="cov0" title="0">{
        // Create mock authentication URL for testing
        baseURL := sp.config.IDPMetadataURL
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = "https://idp.example.com/sso"
        }</span>
        
        // Build authentication URL
        <span class="cov0" title="0">parsedURL, err := url.Parse(baseURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", &amp;SAMLError{
                        Code:    "AUTH_REQUEST_FAILED",
                        Message: "Failed to create SAML authentication request",
                        Details: err.Error(),
                }
        }</span>
        
        <span class="cov0" title="0">query := parsedURL.Query()
        query.Set("SAMLRequest", "mock-saml-request")
        if relayState != "" </span><span class="cov0" title="0">{
                query.Set("RelayState", relayState)
        }</span>
        <span class="cov0" title="0">parsedURL.RawQuery = query.Encode()
        
        return parsedURL.String(), nil</span>
}

// HandleAssertion processes SAML assertion and creates JWT token
func (sp *SAMLProvider) HandleAssertion() fiber.Handler <span class="cov0" title="0">{
        return func(c fiber.Ctx) error </span><span class="cov0" title="0">{
                // This is a simplified version - in production, you'd need to properly
                // integrate with the samlsp middleware and handle the full SAML flow
                
                // For now, we'll simulate processing a SAML assertion
                // In a real implementation, this would extract data from the SAML response
                
                // Extract SAML response from POST data
                samlResponse := c.FormValue("SAMLResponse")
                if samlResponse == "" </span><span class="cov0" title="0">{
                        return sp.sendSAMLError(c, "MISSING_SAML_RESPONSE", "SAML response not found", http.StatusBadRequest)
                }</span>

                // In a real implementation, you would:
                // 1. Decode the base64 SAML response
                // 2. Validate the signature
                // 3. Check timestamps
                // 4. Extract user attributes
                
                // For this implementation, we'll create a mock assertion
                <span class="cov0" title="0">assertion := &amp;SAMLAssertion{
                        Subject:     "mock-user-" + time.Now().Format("20060102150405"),
                        NameID:      "mock@example.com",
                        Email:       "mock@example.com",
                        DisplayName: "Mock User",
                        GivenName:   "Mock",
                        Surname:     "User",
                        Groups:      []string{"users", "employees"},
                        Attributes: map[string]interface{}{
                                "department": "Engineering",
                                "role":       "developer",
                        },
                        SessionIndex: "session-" + time.Now().Format("20060102150405"),
                        NotOnOrAfter: time.Now().Add(8 * time.Hour),
                }

                // Create JWT token from SAML assertion
                tokenPair, err := sp.jwtService.GenerateToken(assertion.Subject, assertion.Email, assertion.DisplayName)
                if err != nil </span><span class="cov0" title="0">{
                        return sp.sendSAMLError(c, "JWT_GENERATION_FAILED", "Failed to generate session token", http.StatusInternalServerError)
                }</span>

                // Get relay state for redirect
                <span class="cov0" title="0">relayState := c.FormValue("RelayState")
                if relayState == "" </span><span class="cov0" title="0">{
                        relayState = "/"
                }</span>

                // Return successful authentication response
                <span class="cov0" title="0">return c.JSON(fiber.Map{
                        "success": true,
                        "token":   tokenPair.AccessToken,
                        "refresh_token": tokenPair.RefreshToken,
                        "expires_at": tokenPair.ExpiresAt.Unix(),
                        "user": fiber.Map{
                                "id":    assertion.Subject,
                                "email": assertion.Email,
                                "name":  assertion.DisplayName,
                        },
                        "assertion": assertion,
                        "relay_state": relayState,
                })</span>
        }
}

// HandleSingleLogout processes SAML single logout requests
func (sp *SAMLProvider) HandleSingleLogout() fiber.Handler <span class="cov0" title="0">{
        return func(c fiber.Ctx) error </span><span class="cov0" title="0">{
                // Extract logout request/response
                logoutRequest := c.FormValue("SAMLRequest")
                logoutResponse := c.FormValue("SAMLResponse")
                
                if logoutRequest == "" &amp;&amp; logoutResponse == "" </span><span class="cov0" title="0">{
                        return sp.sendSAMLError(c, "MISSING_LOGOUT_DATA", "SAML logout request or response not found", http.StatusBadRequest)
                }</span>

                // In a real implementation, you would:
                // 1. Parse and validate the logout request/response
                // 2. Invalidate local sessions
                // 3. Send appropriate logout response
                
                // For now, return a simple success response
                <span class="cov0" title="0">return c.JSON(fiber.Map{
                        "success": true,
                        "message": "Logout successful",
                })</span>
        }
}

// CreateFallbackHandler creates a handler that attempts OIDC first, falls back to SAML
func CreateFallbackHandler(authMiddleware *AuthMiddleware, samlProvider *SAMLProvider) fiber.Handler <span class="cov0" title="0">{
        return func(c fiber.Ctx) error </span><span class="cov0" title="0">{
                // Check if OIDC providers are available and working
                providerName := c.Query("provider")
                
                // Try OIDC first if provider is specified
                if providerName != "" </span><span class="cov0" title="0">{
                        authURL, err := authMiddleware.GetAuthURL(providerName, c.Query("state", "default"))
                        if err == nil </span><span class="cov0" title="0">{
                                return c.JSON(fiber.Map{
                                        "auth_type": "oidc",
                                        "provider":  providerName,
                                        "auth_url":  authURL,
                                })
                        }</span>
                        
                        // Log OIDC failure but don't return error yet
                        <span class="cov0" title="0">fmt.Printf("OIDC authentication failed for provider %s: %v\n", providerName, err)</span>
                }

                // Fall back to SAML
                <span class="cov0" title="0">samlAuthURL, err := samlProvider.GetAuthURL(c.Query("relay_state", ""))
                if err != nil </span><span class="cov0" title="0">{
                        return c.Status(http.StatusInternalServerError).JSON(fiber.Map{
                                "error":   true,
                                "code":    "FALLBACK_FAILED",
                                "message": "Both OIDC and SAML authentication failed",
                        })
                }</span>

                <span class="cov0" title="0">return c.JSON(fiber.Map{
                        "auth_type": "saml",
                        "message":   "Falling back to SAML authentication",
                        "auth_url":  samlAuthURL,
                })</span>
        }
}

// ValidateAssertion validates a SAML assertion (placeholder for actual validation)
func (sp *SAMLProvider) ValidateAssertion(samlResponse string) (*SAMLAssertion, error) <span class="cov8" title="1">{
        // This is a placeholder - in a real implementation you would:
        // 1. Base64 decode the SAML response
        // 2. Parse the XML
        // 3. Validate signatures
        // 4. Check timestamps (NotBefore, NotOnOrAfter)
        // 5. Extract attributes
        // 6. Map to internal user model

        // For now, return a mock assertion
        return &amp;SAMLAssertion{
                Subject:     "saml-user-" + time.Now().Format("20060102150405"),
                NameID:      "saml.user@company.com",
                Email:       "saml.user@company.com",
                DisplayName: "SAML User",
                GivenName:   "SAML",
                Surname:     "User",
                Groups:      []string{"employees", "saml-users"},
                Attributes: map[string]interface{}{
                        "source": "saml",
                        "authenticated_at": time.Now().Unix(),
                },
                SessionIndex: "saml-session-" + time.Now().Format("20060102150405"),
                NotOnOrAfter: time.Now().Add(8 * time.Hour),
        }, nil
}</span>

// GetSupportedSAMLBindings returns supported SAML bindings
func (sp *SAMLProvider) GetSupportedSAMLBindings() []string <span class="cov8" title="1">{
        return []string{
                "HTTP-POST",
                "HTTP-Redirect",
        }
}</span>

// GenerateMetadata generates SAML metadata for the service provider
func (sp *SAMLProvider) GenerateMetadata() (string, error) <span class="cov8" title="1">{
        if sp.serviceProvider == nil </span><span class="cov0" title="0">{
                return "", &amp;SAMLError{
                        Code:    "SP_NOT_INITIALIZED",
                        Message: "SAML service provider not properly initialized",
                }
        }</span>

        // Generate the actual metadata using the crewjam/saml library
        <span class="cov8" title="1">metadata := sp.serviceProvider.ServiceProvider.Metadata()
        
        // Convert to XML bytes
        xmlBytes, err := xml.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                return "", &amp;SAMLError{
                        Code:    "METADATA_GENERATION_FAILED",
                        Message: "Failed to generate SAML metadata",
                        Details: err.Error(),
                }
        }</span>

        <span class="cov8" title="1">return string(xmlBytes), nil</span>
}

// Helper functions

func (sp *SAMLProvider) sendSAMLError(c fiber.Ctx, code, message string, statusCode int) error <span class="cov0" title="0">{
        // Log the error
        fmt.Printf("SAML error: %s - %s\n", code, message)

        return c.Status(statusCode).JSON(fiber.Map{
                "error":   true,
                "code":    code,
                "message": message,
                "type":    "saml_error",
        })
}</span>

func validateSAMLConfig(config SAMLConfig) error <span class="cov8" title="1">{
        if config.EntityID == "" </span><span class="cov8" title="1">{
                return &amp;SAMLError{Code: "INVALID_CONFIG", Message: "Entity ID is required"}
        }</span>
        <span class="cov8" title="1">if config.ACSURL == "" </span><span class="cov8" title="1">{
                return &amp;SAMLError{Code: "INVALID_CONFIG", Message: "ACS URL is required"}
        }</span>
        <span class="cov8" title="1">if config.IDPMetadataURL == "" &amp;&amp; config.IDPMetadataXML == "" </span><span class="cov8" title="1">{
                return &amp;SAMLError{Code: "INVALID_CONFIG", Message: "IDP metadata URL or XML is required"}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func parseCertificateAndKey(privateKeyPEM, certificatePEM string) (*rsa.PrivateKey, *x509.Certificate, error) <span class="cov8" title="1">{
        // Parse private key
        keyBlock, _ := pem.Decode([]byte(privateKeyPEM))
        if keyBlock == nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("failed to parse private key PEM")
        }</span>

        <span class="cov8" title="1">var privateKey *rsa.PrivateKey
        var err error

        if keyBlock.Type == "RSA PRIVATE KEY" </span><span class="cov8" title="1">{
                privateKey, err = x509.ParsePKCS1PrivateKey(keyBlock.Bytes)
        }</span> else<span class="cov0" title="0"> if keyBlock.Type == "PRIVATE KEY" </span><span class="cov0" title="0">{
                keyInterface, err := x509.ParsePKCS8PrivateKey(keyBlock.Bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">var ok bool
                privateKey, ok = keyInterface.(*rsa.PrivateKey)
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("not an RSA private key")
                }</span>
        } else<span class="cov0" title="0"> {
                return nil, nil, fmt.Errorf("unsupported private key type: %s", keyBlock.Type)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to parse private key: %w", err)
        }</span>

        // Parse certificate
        <span class="cov8" title="1">certBlock, _ := pem.Decode([]byte(certificatePEM))
        if certBlock == nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("failed to parse certificate PEM")
        }</span>

        <span class="cov0" title="0">certificate, err := x509.ParseCertificate(certBlock.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to parse certificate: %w", err)
        }</span>

        <span class="cov0" title="0">return privateKey, certificate, nil</span>
}

// SAMLProviderTemplate provides configuration templates for common SAML providers
func GetSAMLProviderTemplates() map[string]SAMLConfig <span class="cov8" title="1">{
        return map[string]SAMLConfig{
                "adfs": {
                        SignRequests:  true,
                        ForceAuthn:   false,
                        AllowIDPInit: true,
                },
                "okta-saml": {
                        SignRequests:  true,
                        ForceAuthn:   true,
                        AllowIDPInit: false,
                },
                "auth0-saml": {
                        SignRequests:  true,
                        ForceAuthn:   false,
                        AllowIDPInit: true,
                },
                "shibboleth": {
                        SignRequests:  false,
                        ForceAuthn:   false,
                        AllowIDPInit: true,
                },
        }
}</span>

// CreateSAMLRoutes creates all SAML-related routes
func CreateSAMLRoutes(app fiber.Router, samlProvider *SAMLProvider) <span class="cov0" title="0">{
        saml := app.Group("/saml")
        
        // Metadata endpoint
        saml.Get("/metadata", samlProvider.GetMetadata())
        
        // Assertion Consumer Service (ACS)
        saml.Post("/acs", samlProvider.HandleAssertion())
        
        // Single Logout Service (SLS)
        saml.Post("/sls", samlProvider.HandleSingleLogout())
        saml.Get("/sls", samlProvider.HandleSingleLogout())
}</span>

// SAMLUserMapper maps SAML assertions to internal user model
type SAMLUserMapper struct {
        EmailAttribute      string            `json:"email_attribute"`
        NameAttribute       string            `json:"name_attribute"`
        GroupsAttribute     string            `json:"groups_attribute"`
        AttributeMapping    map[string]string `json:"attribute_mapping"`
        DefaultRole         string            `json:"default_role"`
}

// MapSAMLUser maps a SAML assertion to user attributes
func (mapper *SAMLUserMapper) MapSAMLUser(assertion *SAMLAssertion) map[string]interface{} <span class="cov8" title="1">{
        userAttributes := make(map[string]interface{})
        
        // Map standard attributes
        userAttributes["sub"] = assertion.Subject
        userAttributes["email"] = assertion.Email
        userAttributes["name"] = assertion.DisplayName
        userAttributes["given_name"] = assertion.GivenName
        userAttributes["family_name"] = assertion.Surname
        userAttributes["groups"] = assertion.Groups
        
        // Map custom attributes based on configuration
        for samlAttr, userAttr := range mapper.AttributeMapping </span><span class="cov8" title="1">{
                if value, exists := assertion.Attributes[samlAttr]; exists </span><span class="cov8" title="1">{
                        userAttributes[userAttr] = value
                }</span>
        }
        
        // Map common attributes directly (for backward compatibility)
        <span class="cov8" title="1">if role, exists := assertion.Attributes["role"]; exists </span><span class="cov8" title="1">{
                userAttributes["role"] = role
        }</span>
        
        // Set default role if not specified
        <span class="cov8" title="1">if mapper.DefaultRole != "" </span><span class="cov8" title="1">{
                if _, hasRole := userAttributes["role"]; !hasRole </span><span class="cov8" title="1">{
                        userAttributes["role"] = mapper.DefaultRole
                }</span>
        }
        
        <span class="cov8" title="1">return userAttributes</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">// Package middleware provides enhanced security features for authentication
package middleware

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/gofiber/fiber/v3"
        "github.com/go-redis/redis/v8"
)

// SecurityConfig holds configuration for security middleware
type SecurityConfig struct {
        // Rate limiting configuration
        RateLimitRequests int           `json:"rate_limit_requests"` // Max requests per window
        RateLimitWindow   time.Duration `json:"rate_limit_window"`   // Rate limit time window
        
        // Brute force protection
        MaxFailedAttempts int           `json:"max_failed_attempts"` // Max failed login attempts
        LockoutDuration   time.Duration `json:"lockout_duration"`    // Account lockout duration
        
        // JWT token rotation
        TokenRotationEnabled bool          `json:"token_rotation_enabled"` // Enable automatic token rotation
        RotationInterval     time.Duration `json:"rotation_interval"`      // How often to rotate tokens
        
        // Redis configuration for distributed security features
        RedisClient redis.UniversalClient `json:"-"` // Redis client for distributed storage
}

// SecurityMiddleware provides enhanced security features
type SecurityMiddleware struct {
        config      SecurityConfig
        rateLimiter *RateLimiter
        bruteForcePrevention *BruteForceProtection
        tokenRotator *TokenRotator
}

// RateLimiter implements distributed rate limiting
type RateLimiter struct {
        config      SecurityConfig
        redisClient redis.UniversalClient
        mu          sync.RWMutex
        localCache  map[string]*RateLimitEntry // Fallback local cache
}

// RateLimitEntry tracks rate limit data for a client
type RateLimitEntry struct {
        Count     int       `json:"count"`
        ResetTime time.Time `json:"reset_time"`
}

// BruteForceProtection implements account lockout after failed attempts
type BruteForceProtection struct {
        config      SecurityConfig
        redisClient redis.UniversalClient
        mu          sync.RWMutex
        localCache  map[string]*BruteForceEntry // Fallback local cache
}

// BruteForceEntry tracks failed attempts for an identifier
type BruteForceEntry struct {
        Attempts     int       `json:"attempts"`
        LastAttempt  time.Time `json:"last_attempt"`
        LockedUntil  time.Time `json:"locked_until"`
        IsLocked     bool      `json:"is_locked"`
}

// TokenRotator manages automatic JWT token rotation
type TokenRotator struct {
        config     SecurityConfig
        jwtService JWTServiceInterface
        ticker     *time.Ticker
        stopChan   chan struct{}
}

// NewSecurityMiddleware creates a new security middleware instance
func NewSecurityMiddleware(config SecurityConfig, jwtService JWTServiceInterface) *SecurityMiddleware <span class="cov8" title="1">{
        // Set default values
        if config.RateLimitRequests == 0 </span><span class="cov8" title="1">{
                config.RateLimitRequests = 100 // 100 requests per window
        }</span>
        <span class="cov8" title="1">if config.RateLimitWindow == 0 </span><span class="cov8" title="1">{
                config.RateLimitWindow = time.Minute // 1 minute window
        }</span>
        <span class="cov8" title="1">if config.MaxFailedAttempts == 0 </span><span class="cov8" title="1">{
                config.MaxFailedAttempts = 5 // 5 failed attempts
        }</span>
        <span class="cov8" title="1">if config.LockoutDuration == 0 </span><span class="cov8" title="1">{
                config.LockoutDuration = 15 * time.Minute // 15 minutes lockout
        }</span>
        <span class="cov8" title="1">if config.RotationInterval == 0 </span><span class="cov8" title="1">{
                config.RotationInterval = 4 * time.Hour // Rotate every 4 hours
        }</span>

        <span class="cov8" title="1">security := &amp;SecurityMiddleware{
                config: config,
                rateLimiter: &amp;RateLimiter{
                        config:      config,
                        redisClient: config.RedisClient,
                        localCache:  make(map[string]*RateLimitEntry),
                },
                bruteForcePrevention: &amp;BruteForceProtection{
                        config:      config,
                        redisClient: config.RedisClient,
                        localCache:  make(map[string]*BruteForceEntry),
                },
        }

        // Initialize token rotator if enabled
        if config.TokenRotationEnabled &amp;&amp; jwtService != nil </span><span class="cov0" title="0">{
                security.tokenRotator = &amp;TokenRotator{
                        config:     config,
                        jwtService: jwtService,
                        stopChan:   make(chan struct{}),
                }
                security.tokenRotator.start()
        }</span>

        <span class="cov8" title="1">return security</span>
}

// RateLimitMiddleware returns a Fiber middleware for rate limiting
func (s *SecurityMiddleware) RateLimitMiddleware() fiber.Handler <span class="cov8" title="1">{
        return func(c fiber.Ctx) error </span><span class="cov8" title="1">{
                clientIP := c.IP()
                allowed, resetTime, err := s.rateLimiter.IsAllowed(clientIP)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but don't block request on rate limiter failure
                        fmt.Printf("Rate limiter error: %v\n", err)
                        return c.Next()
                }</span>

                <span class="cov8" title="1">if !allowed </span><span class="cov8" title="1">{
                        c.Set("X-RateLimit-Limit", fmt.Sprintf("%d", s.config.RateLimitRequests))
                        c.Set("X-RateLimit-Remaining", "0")
                        c.Set("X-RateLimit-Reset", fmt.Sprintf("%d", resetTime.Unix()))
                        
                        return c.Status(429).JSON(fiber.Map{
                                "error":   true,
                                "code":    "RATE_LIMIT_EXCEEDED",
                                "message": "Too many requests. Please try again later.",
                                "retry_after": int(resetTime.Sub(time.Now()).Seconds()),
                        })
                }</span>

                <span class="cov8" title="1">return c.Next()</span>
        }
}

// BruteForceProtectionMiddleware returns a Fiber middleware for brute force protection
func (s *SecurityMiddleware) BruteForceProtectionMiddleware() fiber.Handler <span class="cov8" title="1">{
        return func(c fiber.Ctx) error </span><span class="cov8" title="1">{
                // Check if this is an authentication endpoint
                if c.Path() == "/auth/callback" || c.Path() == "/auth/login" </span><span class="cov8" title="1">{
                        clientIP := c.IP()
                        userAgent := c.Get("User-Agent")
                        identifier := fmt.Sprintf("%s:%s", clientIP, userAgent)

                        isLocked, lockedUntil, err := s.bruteForcePrevention.IsLocked(identifier)
                        if err != nil </span><span class="cov0" title="0">{
                                // Log error but don't block request on protection failure
                                fmt.Printf("Brute force protection error: %v\n", err)
                                return c.Next()
                        }</span>

                        <span class="cov8" title="1">if isLocked </span><span class="cov0" title="0">{
                                return c.Status(423).JSON(fiber.Map{
                                        "error":      true,
                                        "code":       "ACCOUNT_LOCKED",
                                        "message":    "Account temporarily locked due to too many failed attempts",
                                        "locked_until": lockedUntil.Unix(),
                                })
                        }</span>
                }

                <span class="cov8" title="1">return c.Next()</span>
        }
}

// TokenRotationMiddleware adds token rotation headers
func (s *SecurityMiddleware) TokenRotationMiddleware() fiber.Handler <span class="cov8" title="1">{
        return func(c fiber.Ctx) error </span><span class="cov8" title="1">{
                // Add token rotation information to response headers
                if s.config.TokenRotationEnabled </span><span class="cov8" title="1">{
                        c.Set("X-Token-Rotation-Enabled", "true")
                        c.Set("X-Token-Rotation-Interval", s.config.RotationInterval.String())
                }</span>
                <span class="cov8" title="1">return c.Next()</span>
        }
}

// IsAllowed checks if a request is allowed under rate limiting rules
func (rl *RateLimiter) IsAllowed(identifier string) (bool, time.Time, error) <span class="cov8" title="1">{
        ctx := context.Background()
        now := time.Now()
        key := fmt.Sprintf("rate_limit:%s", identifier)

        // Try Redis first if available
        if rl.redisClient != nil </span><span class="cov0" title="0">{
                pipe := rl.redisClient.Pipeline()
                
                // Get current count and expiry
                getCmd := pipe.Get(ctx, key)
                
                // Increment counter
                incrCmd := pipe.Incr(ctx, key)
                
                // Set expiry for new keys
                expireCmd := pipe.Expire(ctx, key, rl.config.RateLimitWindow)
                
                _, err := pipe.Exec(ctx)
                if err != nil &amp;&amp; err != redis.Nil </span><span class="cov0" title="0">{
                        return rl.fallbackLocalRateLimit(identifier, now)
                }</span>

                <span class="cov0" title="0">currentCount := int(incrCmd.Val())
                
                // For new keys, set the expiry
                if getCmd.Err() == redis.Nil </span><span class="cov0" title="0">{
                        expireCmd.Val()
                }</span>

                <span class="cov0" title="0">resetTime := now.Add(rl.config.RateLimitWindow)
                allowed := currentCount &lt;= rl.config.RateLimitRequests

                return allowed, resetTime, nil</span>
        }

        // Fallback to local rate limiting
        <span class="cov8" title="1">return rl.fallbackLocalRateLimit(identifier, now)</span>
}

// fallbackLocalRateLimit provides local rate limiting when Redis is unavailable
func (rl *RateLimiter) fallbackLocalRateLimit(identifier string, now time.Time) (bool, time.Time, error) <span class="cov8" title="1">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        entry, exists := rl.localCache[identifier]
        if !exists || now.After(entry.ResetTime) </span><span class="cov8" title="1">{
                // Create new entry
                entry = &amp;RateLimitEntry{
                        Count:     1,
                        ResetTime: now.Add(rl.config.RateLimitWindow),
                }
                rl.localCache[identifier] = entry
                return true, entry.ResetTime, nil
        }</span>

        // Increment existing entry
        <span class="cov8" title="1">entry.Count++
        allowed := entry.Count &lt;= rl.config.RateLimitRequests

        return allowed, entry.ResetTime, nil</span>
}

// RecordFailedAttempt records a failed authentication attempt
func (bf *BruteForceProtection) RecordFailedAttempt(identifier string) error <span class="cov8" title="1">{
        ctx := context.Background()
        now := time.Now()
        key := fmt.Sprintf("brute_force:%s", identifier)

        // Try Redis first if available
        if bf.redisClient != nil </span><span class="cov0" title="0">{
                // Get current attempts
                _, err := bf.redisClient.Get(ctx, key).Result()
                var entry BruteForceEntry
                
                if err == redis.Nil </span><span class="cov0" title="0">{
                        // New entry
                        entry = BruteForceEntry{
                                Attempts:    1,
                                LastAttempt: now,
                        }
                }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return bf.fallbackLocalRecord(identifier, now)
                }</span> else<span class="cov0" title="0"> {
                        // Parse existing entry
                        // In production, would use proper JSON marshaling
                        entry.Attempts++
                        entry.LastAttempt = now
                }</span>

                // Check if should be locked
                <span class="cov0" title="0">if entry.Attempts &gt;= bf.config.MaxFailedAttempts </span><span class="cov0" title="0">{
                        entry.IsLocked = true
                        entry.LockedUntil = now.Add(bf.config.LockoutDuration)
                }</span>

                // Store updated entry with TTL
                <span class="cov0" title="0">ttl := bf.config.LockoutDuration
                if !entry.IsLocked </span><span class="cov0" title="0">{
                        ttl = time.Hour // Keep failed attempts for 1 hour
                }</span>
                
                // In production, would marshal to JSON properly
                <span class="cov0" title="0">return bf.redisClient.Set(ctx, key, fmt.Sprintf("attempts:%d", entry.Attempts), ttl).Err()</span>
        }

        // Fallback to local storage
        <span class="cov8" title="1">return bf.fallbackLocalRecord(identifier, now)</span>
}

// fallbackLocalRecord provides local brute force tracking when Redis is unavailable
func (bf *BruteForceProtection) fallbackLocalRecord(identifier string, now time.Time) error <span class="cov8" title="1">{
        bf.mu.Lock()
        defer bf.mu.Unlock()

        entry, exists := bf.localCache[identifier]
        if !exists </span><span class="cov8" title="1">{
                entry = &amp;BruteForceEntry{}
                bf.localCache[identifier] = entry
        }</span>

        <span class="cov8" title="1">entry.Attempts++
        entry.LastAttempt = now

        // Check if should be locked
        if entry.Attempts &gt;= bf.config.MaxFailedAttempts </span><span class="cov8" title="1">{
                entry.IsLocked = true
                entry.LockedUntil = now.Add(bf.config.LockoutDuration)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsLocked checks if an identifier is currently locked due to brute force attempts
func (bf *BruteForceProtection) IsLocked(identifier string) (bool, time.Time, error) <span class="cov8" title="1">{
        ctx := context.Background()
        key := fmt.Sprintf("brute_force:%s", identifier)
        now := time.Now()

        // Try Redis first if available
        if bf.redisClient != nil </span><span class="cov0" title="0">{
                _, err := bf.redisClient.Get(ctx, key).Result()
                if err == redis.Nil </span><span class="cov0" title="0">{
                        return false, time.Time{}, nil
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return bf.fallbackLocalCheck(identifier, now)
                }</span>

                // In production, would properly parse JSON
                // For now, simple check if key exists means locked
                <span class="cov0" title="0">return true, now.Add(bf.config.LockoutDuration), nil</span>
        }

        // Fallback to local check
        <span class="cov8" title="1">return bf.fallbackLocalCheck(identifier, now)</span>
}

// fallbackLocalCheck provides local brute force checking when Redis is unavailable
func (bf *BruteForceProtection) fallbackLocalCheck(identifier string, now time.Time) (bool, time.Time, error) <span class="cov8" title="1">{
        bf.mu.RLock()
        defer bf.mu.RUnlock()

        entry, exists := bf.localCache[identifier]
        if !exists </span><span class="cov8" title="1">{
                return false, time.Time{}, nil
        }</span>

        <span class="cov8" title="1">if entry.IsLocked </span><span class="cov8" title="1">{
                if now.After(entry.LockedUntil) </span><span class="cov0" title="0">{
                        // Lock has expired, clean up
                        delete(bf.localCache, identifier)
                        return false, time.Time{}, nil
                }</span>
                <span class="cov8" title="1">return true, entry.LockedUntil, nil</span>
        }

        <span class="cov8" title="1">return false, time.Time{}, nil</span>
}

// ClearFailedAttempts clears failed attempts for an identifier (on successful login)
func (bf *BruteForceProtection) ClearFailedAttempts(identifier string) error <span class="cov8" title="1">{
        ctx := context.Background()
        key := fmt.Sprintf("brute_force:%s", identifier)

        // Clear from Redis if available
        if bf.redisClient != nil </span><span class="cov0" title="0">{
                bf.redisClient.Del(ctx, key)
        }</span>

        // Clear from local cache
        <span class="cov8" title="1">bf.mu.Lock()
        defer bf.mu.Unlock()
        delete(bf.localCache, identifier)

        return nil</span>
}

// start begins the token rotation process
func (tr *TokenRotator) start() <span class="cov8" title="1">{
        if tr.ticker != nil </span><span class="cov0" title="0">{
                tr.ticker.Stop()
        }</span>

        <span class="cov8" title="1">tr.ticker = time.NewTicker(tr.config.RotationInterval)
        
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-tr.ticker.C:<span class="cov8" title="1">
                                tr.rotateExpiredTokens()</span>
                        case &lt;-tr.stopChan:<span class="cov8" title="1">
                                return</span>
                        }
                }
        }()
}

// stop stops the token rotation process
func (tr *TokenRotator) Stop() <span class="cov8" title="1">{
        if tr.ticker != nil </span><span class="cov8" title="1">{
                tr.ticker.Stop()
        }</span>
        <span class="cov8" title="1">close(tr.stopChan)</span>
}

// rotateExpiredTokens rotates tokens that are close to expiration
func (tr *TokenRotator) rotateExpiredTokens() <span class="cov8" title="1">{
        // In production, this would:
        // 1. Query active sessions nearing expiration
        // 2. Generate new tokens for those sessions
        // 3. Update Redis with new token mappings
        // 4. Mark old tokens for cleanup
        
        fmt.Printf("Token rotation cycle executed at %v\n", time.Now())
        
        // This is a placeholder - in production would implement actual rotation logic
        // that works with the JWT service and session storage
}</span>

// GetSecurityMetrics returns current security metrics
func (s *SecurityMiddleware) GetSecurityMetrics() map[string]interface{} <span class="cov8" title="1">{
        metrics := map[string]interface{}{
                "rate_limiter": map[string]interface{}{
                        "enabled":        true,
                        "requests_limit": s.config.RateLimitRequests,
                        "window":         s.config.RateLimitWindow.String(),
                },
                "brute_force_protection": map[string]interface{}{
                        "enabled":            true,
                        "max_failed_attempts": s.config.MaxFailedAttempts,
                        "lockout_duration":   s.config.LockoutDuration.String(),
                },
                "token_rotation": map[string]interface{}{
                        "enabled":  s.config.TokenRotationEnabled,
                        "interval": s.config.RotationInterval.String(),
                },
        }

        // Add local cache statistics if available
        if s.rateLimiter != nil </span><span class="cov8" title="1">{
                s.rateLimiter.mu.RLock()
                metrics["rate_limiter"].(map[string]interface{})["local_cache_entries"] = len(s.rateLimiter.localCache)
                s.rateLimiter.mu.RUnlock()
        }</span>

        <span class="cov8" title="1">if s.bruteForcePrevention != nil </span><span class="cov8" title="1">{
                s.bruteForcePrevention.mu.RLock()
                metrics["brute_force_protection"].(map[string]interface{})["local_cache_entries"] = len(s.bruteForcePrevention.localCache)
                s.bruteForcePrevention.mu.RUnlock()
        }</span>

        <span class="cov8" title="1">return metrics</span>
}

// Cleanup performs cleanup of expired entries and resources
func (s *SecurityMiddleware) Cleanup() <span class="cov8" title="1">{
        now := time.Now()

        // Cleanup rate limiter local cache
        if s.rateLimiter != nil </span><span class="cov8" title="1">{
                s.rateLimiter.mu.Lock()
                for key, entry := range s.rateLimiter.localCache </span><span class="cov8" title="1">{
                        if now.After(entry.ResetTime) </span><span class="cov8" title="1">{
                                delete(s.rateLimiter.localCache, key)
                        }</span>
                }
                <span class="cov8" title="1">s.rateLimiter.mu.Unlock()</span>
        }

        // Cleanup brute force protection local cache
        <span class="cov8" title="1">if s.bruteForcePrevention != nil </span><span class="cov8" title="1">{
                s.bruteForcePrevention.mu.Lock()
                for key, entry := range s.bruteForcePrevention.localCache </span><span class="cov8" title="1">{
                        if entry.IsLocked &amp;&amp; now.After(entry.LockedUntil) </span><span class="cov8" title="1">{
                                delete(s.bruteForcePrevention.localCache, key)
                        }</span>
                }
                <span class="cov8" title="1">s.bruteForcePrevention.mu.Unlock()</span>
        }

        // Stop token rotator if needed
        <span class="cov8" title="1">if s.tokenRotator != nil </span><span class="cov0" title="0">{
                s.tokenRotator.Stop()
        }</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
